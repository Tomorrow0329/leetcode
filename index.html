<div id="app">sdfsfds</div>

<script>

    /*
    * å­—ç¬¦ä¸²-ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„
    * è¿™ä¸ªé¢˜ç›¸å½“å¥½å•Šï¼Œè™½ç„¶ç®€å•ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆã€äºŒåˆ†æ³• æ¥åšï¼›
    */

    // 1ã€å•ä¸ªå¤§äº9çš„ å»æ‰ï¼›
    // 2ã€å’Œå°äº9çš„ å»æ‰ï¼›
    const arr = [-1,0];
    const target = -1;

    const twoSum = function(numbers, target) {
        let i = 0;
        let j = numbers.length - 1;
        while (i < j) {
            const sum = numbers[i] + numbers[j];
            if (sum === target) return [i + 1, j + 1];
            sum > target ? j-- : i++
        }
    };

    console.log(twoSum(arr, target));

// ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹
/*
* æ•°ç»„--å¯¹è§’çº¿éå†
*/  
// [[1,2,3],[4,5,6],[7,8,9]]

// var findDiagonalOrder = function(matrix) {
//     if (matrix && matrix.length === 0) return matrix; 
//     if (!Array.isArray(matrix[0])) return matrix;
//     let directionFlag = 'up';
//     let isTrans = false;
//     const N = matrix.length;
//     const M = matrix[0].length;

//     const basicMatrix = Object.assign([], matrix);
//     matrix = [];
//     let x = 0, y = 0;

//     if (M === 1 || N === 1) { // å•é¡¹äºŒç»´æ•°ç»„
//         matrix = [].concat.apply([], basicMatrix)
//         return matrix 
//     }


//     matrix.push(basicMatrix[x][y]);

//     while ((x < N -1) || (y < M - 1)) {
//         if ((x === N -1) && (y === M - 1)) break;

//         switch (directionFlag) {
//             case 'up':
//             if (isTrans) {
//                 x = x - 1;
//                 y = y + 1;
//                 isTrans = false;
//                 break;
//             }
//             if (y === M - 1) {
//                 isTrans = false;
//                 x = x + 1;
//                 y =  y + 0;
//                 directionFlag = 'down';
//             } else if (x === 0) {
//                 isTrans = true;
//                 x = x + 0;
//                 y =  y + 1;
//                 directionFlag = 'down';
//             } else {
//                 x = x - 1;
//                 y =  y + 1;
//             }
//             break;
//             case 'down':
//             if (isTrans) {
//                 x = x + 1;
//                 y = y - 1;
//                 isTrans = false;
//                 break;
//             }
//             if (x === N - 1) {
//                 isTrans = true;
//                 x = x + 0;
//                 y =  y + 1;
//                 directionFlag = 'up';
//             } else if (y === 0) {
//                 isTrans = false;
//                 x = x + 1;
//                 y =  y + 0;
//                 directionFlag = 'up';
//             } else {
//                 x = x + 1;
//                 y =  y - 1;
//             }
//             break;
//             default: break;
//         }
//         matrix.push(basicMatrix[x][y]);
//     }
//     return matrix;

// };
// console.log(findDiagonalOrder([[6],[7],[0]]))

// console.log(findDiagonalOrder(
// [
//  [ 1, 2, 3, 4, 5, 6 ],
//  [ 7, 8, 9, 10, 11, 12 ],
//  [ 13, 14, 15, 16, 17, 18 ],
//  [ 19, 20, 21, 22, 23, 24]
// ]))


// ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹
/*
* æ•°ç»„--æ—‹è½¬çŸ©é˜µ
*/
/**
 * matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
] 
*/
// é¢˜ç›®ï¼šç»™ä½ ä¸€å¹…ç”± N Ã— N çŸ©é˜µè¡¨ç¤ºçš„å›¾åƒï¼Œå…¶ä¸­æ¯ä¸ªåƒç´ çš„å¤§å°ä¸º 4 å­—èŠ‚ã€‚è¯·ä½ è®¾è®¡ä¸€ç§ç®—æ³•ï¼Œå°†å›¾åƒæ—‹è½¬ 90 åº¦ã€‚ä¸å ç”¨é¢å¤–å†…å­˜ç©ºé—´èƒ½å¦åšåˆ°ï¼Ÿ
// å…³é”®ï¼šç¬¬iè¡Œçš„ç¬¬jä¸ªå…ƒç´ ï¼Œæ—‹è½¬å å˜ä¸ºå€’æ•°ç¬¬iåˆ— ç¬¬jä¸ªå…ƒç´ 
// const matrix =
// [
//   [ 5, 1, 9,11],
//   [ 2, 4, 8,10],
//   [13, 3, 6, 7],
//   [15,14,12,16]
// ] 
// var rotate = function(matrix) {
//     const length = matrix.length;
//     const newMatrix = new Array(length).fill(0).map((item) => new Array(length).fill(0));
//     for (let i = 0; i < length; i++) {
//         for (let j = 0; j < length; j++) {
//             newMatrix[j][length -1 - i] = matrix[i][j];
//         }
//     }

//     for (let i = 0; i < length; i++) {
//         for (let j = 0; j < length; j++) {
//             matrix[i][j] = newMatrix[i][j];
//         }
//     }

//     return newMatrix; // è¿™ä¸ªé¢˜ å¾ˆç¥å¥‡çš„ æ˜¯return æ— æ•ˆã€‚ã€‚ã€‚ã€‚æ‰€ä»¥å¿…é¡»è¦æŠŠ matrix æ”¹æˆè·ŸnewMatrix ä¸€æ ·çš„ã€‚ã€‚

// };

// console.log(rotate(matrix))

// ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹ğŸŒ¹
/*
* æ•°ç»„--åˆå¹¶åŒºé—´
*/
    // [[0,2], [1,4], [3,5]]

    // æ‰§è¡Œç”¨æ—¶ï¼š100 ms, åœ¨æ‰€æœ‰ JavaScript æäº¤ä¸­å‡»è´¥äº† 50.58% çš„ç”¨æˆ·;
    // å†…å­˜æ¶ˆè€—ï¼š41.9 MB, åœ¨æ‰€æœ‰ JavaScript æäº¤ä¸­å‡»è´¥äº† 9.39% çš„ç”¨æˆ·;
    var merge = function(intervals) {
        intervals.sort((a, b) => a[0] - b[0]);
        const length = intervals.length;
        const newIntervals = [];
        let i = 0;
        const fn = (item) => {
            if (!intervals[i + 1]) return intervals;

            const start = item[0];
            const end = item[1];
            let startNext = intervals[i+1][0];
            let endNext = intervals[i+1][1];

            if (end >= startNext && start <= startNext) {
                intervals.splice(i, 2, [Math.min(start, startNext), Math.max(end, endNext)]);
                fn(intervals[i]);
            } else {
                i++;
                fn(intervals[i]);
                // fn(intervals[i++]); // i++ è¿™ç§å†™æ³• è¯»å–çš„æ˜¯ç¬¬ié¡¹ï¼Œç„¶åæ‰è‡ªåŠ ä¸€ï¼
            } 
        }
        fn(intervals[i])
        return intervals;
    }
    // console.log(merge([[1,4],[0,2],[3,5]]))
    // console.log(merge([[2,3],[2,2],[3,3],[1,3],[5,7],[2,2],[4,6]]))

    // æ‰§è¡Œç”¨æ—¶ï¼š112 ms, åœ¨æ‰€æœ‰ JavaScript æäº¤ä¸­å‡»è´¥äº† 20.72% çš„ç”¨æˆ·;
    // å†…å­˜æ¶ˆè€—ï¼š39.6 MB, åœ¨æ‰€æœ‰ JavaScript æäº¤ä¸­å‡»è´¥äº† 57.71% çš„ç”¨æˆ·;

    var merge = function(intervals) {
        intervals.sort((a, b) => a[0] - b[0]);

        const newIntervals = [];
        newIntervals.push(intervals[0]);

        for (var i = 0; i < intervals.length; i++) {
            if (intervals[i][0] > newIntervals[newIntervals.length - 1][1]) {
                newIntervals.push(intervals[i]);
            } else if (intervals[i][1] >= newIntervals[newIntervals.length - 1][1]) {
                newIntervals[newIntervals.length - 1][1] = intervals[i][1];
            }
        }

        return newIntervals;
    }

    // console.log(merge([[1,4],[0,2],[3,5]]))
    // console.log(merge([[1,4],[0,2],[3,5]]))

</script>